% Package
\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{cite}
\usepackage{graphicx}

\title{ADP Aufgabe 1, Abgabe 1}
\author{Team 1\\Hugo Protsch, Justin Hoffmann}

% Document
\begin{document}

    \maketitle


    \section{Formales}\label{sec:Formales}

    %! suppress = MissingLabel

    \subsection{Aufgabenaufteilung}
    Die Entwürfe wurden zusammen entwickelt.
    %! suppress = MissingLabel

    \subsection{Quellenangaben}
    Es wurden lediglich Vorlesungsmaterialien verwendet.

    %! suppress = MissingLabel

    \subsection{Bearbeitungszeitraum}
    Für die Bearbeitung haben wir in etwa 8 bis 10 Stunden benötigt.
    %! suppress = MissingLabel

    \subsection{Aktueller Stand}
    Die Entwürfe sind fertig gestellt und müssen Implementiert werden.

    %! suppress = MissingLabel

    \subsection{Änderungen des Entwurfes}
    -- Nicht zutreffend --


    \section{Entwürfe}\label{sec:entwuerfe}

    \subsection{InitBT}\label{subsec:initbt}
    Liefert einen leeren Baum.
    Der Entwurf ist trivial.
    Die erwartete Laufzeit beträgt
    \begin{math}
        \Theta(1)
    \end{math}

    \subsection{IsEmptyBT}\label{subsec:isemptybt}
    Prüft einen Baum auf Leerheit.
    Da der Baum nicht auf Korrektheit zu prüfen ist,
    ist der Entwurf trivial.
    Die erwartete Laufzeit beträgt
    \begin{math}
        \Theta(1)
    \end{math}

    \subsection{IsBt}\label{subsec:isbt}

    \begin{center}
        \includegraphics[width=1.2\columnwidth] {isBt}
    \end{center}

    Prüft die vorgegebenen Rahmenbedingungen eines übergebenen Baums.
    Hierbei werden alle Wahrheitswerte der verschiedenen
    Vorgaben von jedem Knoten miteinander in einen logischen
    Zusammenhang gebracht.

    Die erwartete Laufzeit beträgt
    \begin{math}
        O(1)
    \end{math}

    \subsection{EqualsBT}\label{subsec:equalsbt}
    Prüft auf semantische Gleichheit zwischen zwei Bäumen.
    Entwurf ist ebenfalls trivial, da die inOrderBT-Funktion
    auf beide Bäume angewendet wird und die resultierenden Listen verglichen werden.

    Die erwartete Laufzeit beträgt
    \begin{math}
        O(n)
    \end{math},
    da die Bäume unabhängig voneinander durchlaufen werden, im Anschluss wird
    ein Mal über eine Liste von n Elementen iteriert.

    \subsection{InsertBT}\label{subsec:insertbt}

    \begin{center}
        \includegraphics[width=1\columnwidth] {insert}
    \end{center}

    Fügt ein übergebenes Element einem übergebenem Baum hinzu.
    Zum Traversieren des Baumes wird bei jedem Schritt überprüft,
    ob das einzufügende Element kleiner oder größer dem derzeitigen Knoten-Element ist.
    Ist es kleiner geht man nach links, größer nach rechts.
    Die Höhe wird dynamisch angepasst.
    Ist ein leerer Platz gefunden,
    wird das Element dort eingefügt.

    Die erwartete Laufzeit beträgt
    \begin{math}
        O(n)
    \end {math}
    bzw.
    \begin{math}
        \Theta (log (n))
    \end{math},
    da der Baum im Worst-Case nicht ausgeglichen ist.
    Das hat zur Folge, dass alle Elemente einmal durchlaufen werden müssen.
    Durchschnittlich wird der Baum mit einer logarithmischen Komplexität
    traversiert, da bei einem ausgeglichenem Baum durch die vertikale
    Traversierung nur
    \begin{math}
        log (n)
    \end{math}
    Elemente durchlaufen werden.

    \subsection{DeleteBT}\label{subsec:deletebt}

    \begin{center}
        \includegraphics[width=0.8\columnwidth] {delete}
    \end{center}

    Löscht ein übergebenes Element aus einem übergebenem Baum.
    Die Traversierung des Baums ist gleich wie bei InsertBT.
    Ist das Ende des Baumes erreicht, ohne das Element gefunden zu haben,
    wird der Baum unverändert zurückgegeben.
    Wird das Element aufgefunden,
    kommt an seine Stelle das Element aus dem linken Teilbaum mit dem höchsten Wert.
    Die Höhe wird Bottom-Up angepasst.

    Die erwartete Laufzeit beträgt
    \begin{math}
        O(n)
    \end {math}
    bzw.
    \begin{math}
        \Theta (log (n))
    \end{math},
    aufgrund der bei InsertBT erwähnten Umstände.

    \subsection{Find}\label{subsec:find}

    \begin{center}
        \includegraphics[width=1.1\columnwidth] {find.pdf}
    \end{center}

    Gibt die Höhe eines übergebenem Elements in einem übergebenem Baum aus.
    Traversieren des Baums funktioniert hierbei gleich wie in InsertBT.
    Ist das Element gefunden, wird die Höhe des Knotens ausgegeben.

    Die erwartete Laufzeit beträgt
    \begin{math}
        O(n)
    \end {math}
    bzw.
    \begin{math}
        \Theta (log (n))
    \end{math},
    aufgrund der bei InsertBT erwähnten Umstände.

    \subsection{InOrderBT}\label{subsec:inorderbt}

    \begin{center}
        \includegraphics[width=0.4\columnwidth] {inorderhugo.pdf}
        \includegraphics[width=0.5\columnwidth] {inorderjustin.pdf}
    \end{center}

    Gibt den Baum in Inorder in einer Liste aus.
    Es wird eine Liste mit dem Element des Knotens erstellt,
    wobei die Inorder des linken Kindes vorangestellt und die
    Inorder des rechten Kindes herangehängt wird.
    Ist das Ende des Baumes erreicht, wird eine leere Liste zurückgegeben.

    Hier haben wir zwei Optionen dargestellt: Zum Einen kann bei jedem
    Funktionsdurchlauf der derzeitige Knoten selbst betrachtet werden (rechts).
    Zum anderen gibt es die Möglichkeit, bei der Überprüfung der Komponenten
    vorauszueilen und immer auf die Kinder des derzeitigen Knotens zu achten (links).
    Die Auswahl des Entwurfes ist implementationsabhängig.

    Die erwartete Laufzeit beträgt
    \begin{math}
        \Theta (n)
    \end{math},
    da jedes Element des Baums durchlaufen wird.
    Hierbei ist zu beachten, dass die Gesamtkomplexität des weiteren von der
    Komplexität der Append- bzw. Prepend-Operation der Liste abhängt.
    Falls die Komplexität dieser Operation
    \begin{math}
        O(n)
    \end{math}
    beträgt, ergibt sich daraus eine Gesamtkomplexität von
    \begin{math}
        O(log(n) \cdot n)
    \end{math}

\end{document}
